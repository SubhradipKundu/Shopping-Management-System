# Shopping-Management-System
The main objective of the project is to help to the ongoing users help to attain an easy way to negative the customer’s problems. Maintaining the value of materials. It is basically a very instant processing system by which customer can get their product with a proper packaging and invoice bill. It’s basically build in the C++ platform.
# 1.Title of the project :-
Development of a feature-rich, Shopping Management System. 

# 2.	Introduction and Objectives of the Project :-
 The main objective of the project is to help to the ongoing users help to attain an easy way to negative the customer’s problems. Maintaining the value of materials. It is basically a very instant processing system by which customer can get their product with a proper packaging and invoice bill. It’s basically build in the C++ platform.

#  PROJECT CATEGORY:-
Desktop Application
# 3.	Tools/Platform, Hardware & Software Requirement specifications :-
- Tools :-
Block code           
Ms-Office
- Platform :-
Microsoft Windows 10	 
Hardware Requirement Specification
Client Machine
HDD	200 MB
Processor	Pentium 4 or newer processor that supports SSE2
Memory	512	

# 4.	  Goals of Implementation :-
The implementation aims to simplify shopping for a customer. 


# 5.	  Non Functional Requirements :-
In addition to the obvious features and functions that you will provide in your system, there are other requirements that don't actually DO anything, but are important characteristics nevertheless. These are called "non-functional requirements" or sometimes "Quality Attributes."  For example, attributes such as performance, security, usability, compatibility. Aren’t a "feature" of the system, but are a required characteristic. You can't write a specific line of code to implement them; rather they are "emergent" properties that arise from the entire solution. The specification needs to describe any such attributes the customer requires. You must decide the kind of requirements that apply to your project and include those that are appropriate.
Each requirement is simply stated in English. Each requirement must be objective and quantifiable; there must be some measurable way to assess whether the requirement has been met.

Often deciding on quality attributes requires making tradeoffs, e.g., between performance and maintainability. In the APPENDIX you must include an engineering analysis of any significant decisions regarding tradeoffs between competing attributes.
Here are some examples of non-functional requirements:


-	Performance requirements :-
Requirements about resources required, response time, transaction rates, throughput, benchmark specifications or anything else having to do with performance. 
-	Operating constraints :-
List any run-time constraints. This could include system resources, people, and needed software.
The application must run without any manual intervention.
-	Platform constraints :-
Discuss the target platform. Be as specific or general as the user requires. If the user doesn't care, there are still platform constraints.
Since the application will be developed in PHP it is platform independent.
-	Accuracy and Precision :-
Requirements about the accuracy and precision of the data. (Do you know the difference?) Beware of 100% requirements; they often cost too much.
-	Modifiability :-
Requirements about the effort required to make changes in the software. Often, the measurement is personnel effort (person- months).
Minimal
-	Portability :-
The effort required to move the software to a different target platform. The measurement is most commonly person-months or % of modules that need changing.
Minimal
-	Reliability :-
Requirements about how often the software fails. The measurement is often expressed in MTBF (mean time between failures). The definition of a failure must be clear. Also, don't confuse reliability with availability which is quite a different kind of requirement.  Be sure to specify the consequences of software failure, how to protect from failure, a strategy for error detection, and a strategy for correction.


-	Security :-
One or more requirements about protection of your system and its data. The measurement can be expressed in a variety of ways (effort, skill level, time ...) to break into the system.  Do not discuss solutions (e.g. passwords) in a requirements document.
Only secured users can access the application.
No one can go to any independent page without logging in.
-	Usability :-
Requirements about how difficult it will be to learn and operate the system. The requirements are often expressed in learning time or similar metrics.
-	Legal :-
There may be legal issues involving privacy of information, intellectual property rights, export of restricted technologies, etc.

 
# 6.	  Feasibility Study :-
You should provide a feasibility report in the following format:
-	Product: A general statement of the product; give a brief description of what the proposed system will do, highlighting where the proposed system meets the specified business requirements of the organization.
-	Technical Feasibility: Will the proposed system perform to the required specification? Outline technical systems options you propose to use, which will give a technical solution satisfying the requirements and constraints of the system, as outlined in the terms of reference.
-	Social Feasibility: Consideration of whether the proposed system would prove acceptable to the people who would be affected by its introduction. Describe the effect on users from the introduction of the new system; consider whether there will be a need for retraining the workforce. Will there be a need for relocation of some of the workforce? Will some jobs become deskilled? Will the current workforce be able to perform effectively any new tasks introduced by the proposed system? Describe how you propose to ensure user co-operation before changes are introduced.
-	Economic Feasibility: Consider the cost/benefits of the proposed system. Detail the costs that will be incurred by the organization adopting the new system; consider development costs and running costs. Detail benefits that the new system will bring, direct economic benefits such as reduced costs, and indirect benefits, such as improved management information and better customer service. Illustrate the cost/benefit of the new system by applying a suitable cost/benefit analysis method such as the payback method.
-	Market Research: A comprehensive market research identifying a need for the product. Detail all market research you carried out, listing sources of information. Justify any conclusions you have drawn from your research. Identify the potential customer base for your product, together with evidence of customer need for the product. Describe how you propose to compete with similar products on the market.
-	Alternative Solution: Consideration of alternative solutions should be documented. At least two alternative business or technical systems options should be considered. Detail the differences between these options and the proposed system. Justify your choice of the proposed system and the reasons for rejecting the alternative options.
At this point, all of the planning for the project has been done and if the feasibility study has shown that the project is likely to succeed within its constraints, then it only remains for us to start the requirements analysis and thus proceed with the project.
-	Feasibility study  :-
You should provide a feasibility report in the following format:
-	Product: A general statement of the product; give a brief description of what the proposed system will do, highlighting where the proposed system meets the specified business requirements of the organization.
-	Technical Feasibility: Will the proposed system perform to the required specification? Outline technical systems options you propose to use, which will give a technical solution satisfying the requirements and constraints of the system, as outlined in the terms of reference.
-	Social Feasibility: Consideration of whether the proposed system would prove acceptable to the people who would be affected by its introduction. Describe the effect on users from the introduction of the new system; consider whether there will be a need for retraining the workforce. Will there be a need for relocation of some of the workforce? Will some jobs become deskilled? Will the current workforce be able to perform effectively any new tasks introduced by the proposed system? Describe how you propose to ensure user co-operation before changes are introduced.
-	Economic Feasibility: Consider the cost/benefits of the proposed system. Detail the costs that will be incurred by the organization adopting the new system; consider development costs and running costs. Detail benefits that the new system will bring, direct economic benefits such as reduced costs, and indirect benefits, such as improved management information and better customer service. Illustrate the cost/benefit of the new system by applying a suitable cost/benefit analysis method such as the payback method.
-	Market Research: A comprehensive market research identifying a need for the product. Detail all market research you carried out, listing sources of information. Justify any conclusions you have drawn from your research. Identify the potential customer base for your product, together with evidence of customer need for the product. Describe how you propose to compete with similar products on the market.
Alternative Solution: Consideration of alternative solutions should be documented. At least two alternative business or technical systems options should be considered. Detail the differences between these options and the proposed system. Justify your choice of the proposed system and the reasons for rejecting the alternative options. At this point, all of the planning for the project has been done and if the feasibility study has shown that the project is likely to succeed within its constraints, then it only remains for us to start the requirements analysis and thus proceed with the project.

# 7.	  Project Planning :-
Project planning is concerned with identifying the following for every project:
-	Activities
-	Milestones
-	Deliverable.
A plan must be drawn up to guide the development towards the project goal. A plan is drawn up at the start of a project. This plan should be used as the driver for the project. The initial plan is not static, and must be modified as the project progresses.
Planning is required for development activities from specification through to delivery of the system.
# 8.	Coding:-
Main.cpp
#include<bits/stdc++.h>
#include<fstream>
#include<conio.h>
#include"../../../conio2.h"
#include"../../../men_section.h"
#include"../../../women_section.h"
#include"../../../windowms.h"
#include"../../../locTime.h"
#include"../../../kids_section.h"
#define el cout<<endl;
using namespace std;

void window1();
void welcome()
{
    time();
    int a = 70;
    int b = 18;
    gotoxy(a,b);
    string element[]={"||WELCOME TO THE SHOP||", "||CREATED BY||", "||ARIJIT CHAKRABORTY||", "||SUBHRADIP KUNDU||", "||KAJAL ROY||", "||PRABIR PAL||"};
    for(int i = 0;i<6;i++)
    {
        textcolor(GREEN);
        gotoxy(a+3,b+2*i);
        cout<<element[i];
    }

   {
        textcolor(WHITE);
        gotoxy(a+3,b+2*6);
        cout<<" PRESS ENTER";
    }

    int choice = getch();
    switch(choice)
    {
    case 13:
        window1();
        break;
    }
}

void window1()
{
    int a = 70;
    int b = 18;
	system("cls");
	time();
	gotoxy(a,b);
    textcolor(GREEN);
    string element[]={"FOR WHOM YOU WANT TO BUY?", "1. MEN'S", "2. WOMEN'S", "3. KID'S", "4. EXIT"};
    for(int i = 0;i<5;i++)
    {
        textcolor(GREEN);
        gotoxy(a+1,b+2*i);
        cout<<element[i];
    }
    gotoxy(a+1,b+2*5);
    cout<<"ENTER YOUR CHOICE(1 TO 4) : ";
    textbackground(WHITE);
    cout<<"    ";
    textbackground(BLACK);
    int choice;
    gotoxy(a+29,b+10);
    cin>>choice;
    textbackground(BLACK);
    switch(choice)
    {
    case 1:
        menmain();
        break;
    case 2:
        womenmain();
        break;
    case 3:
        kidsmain();
        break;
    case 4:
        exit(1);
        break;
    default:
        gotoxy(a,b+12);
        cout<<"WRONG INPUT!";
}
}
int main()
{
    MoveWindowSize(-8,-5,2000,2000);
    welcome();
}
kids.cpp
#include<bits/stdc++.h>
#include<fstream>
#include<conio.h>
#include"../conio2.h"
#include"../locTime.h"
#define el cout<<endl;
using namespace std;

int kids(int a, int b,string mn[]);
void kid_sweaters_jackets(int a, int b);
void kid_caps_hats(int a,int b);
void kid_BODYSUITS(int a,int b);
void kid_ROMPERS_SLEEPSUITS(int a,int b);
void kid_CLOTHINGSET(int a,int b);
void window1();
void kidsmain()
{
    string mn[8]=
    {
    "WELCOME TO THE KIDS'S SECTION",
    "What would you like to buy? ",
    "1. SWEATERS AND JACKETS",
    "2. CAPS AND HAT",
    "3. BODYSUITS",
    "4. ROMPERS&SLEEPSUITS",
    "5. CLOTHINGSET",
    "0. PREVIOUS MENU",
    };
    int a=68, b=12;
    kids(a,b,mn);

}
int kids(int a, int b, string mn[])
{
    system("cls");
    time();
    int i=0;
    while(i<8)
    {
        gotoxy(a,b+2*i);
        textcolor(GREEN);
        cout<<mn[i]<<endl;
        i++;
    }
    gotoxy(a,b+22);
    cout<<"ENTER YOUR CHOICE(0 TO 5) : ";
    textbackground(WHITE);
    cout<<"    ";
    textbackground(BLACK);
    int choice;
    gotoxy(a+29,b+22);
    cin>>choice;
    textbackground(BLACK);

    switch(choice)
    {
    case 1:
        kid_sweaters_jackets(a,b);
        break;
    case 2:
        kid_caps_hats(a,b);
        break;
    case 3:
        kid_BODYSUITS(a,b);
        break;
    case 4:
        kid_ROMPERS_SLEEPSUITS(a,b);
        break;
    case 5:
        kid_CLOTHINGSET(a,b);
        break;
    case 0:
        window1();
        break;
    default:
        gotoxy(a,b+25);
        cout<<"WRONG INPUT!";
    }

}

void kid_sweaters_jackets(int a,int b)
{
    system("cls");
    time();
    string mn[4]=
    {
        "PRICE LIST.......",
        "1. V NECK\t\t:  Rs 699    ",
        "2. ROUND NECK\t:  Rs 499",
        "3. TURTLE NECK\t:  Rs 799",
        };
        int i=0;
        while(i<4)
    {
        gotoxy(a,b+5+2*i);
        textcolor(GREEN);
        cout<<mn[i]<<endl;
        i++;
    }
    gotoxy(a,b+4*i);
    cout<<"PRESS BACKSPACE TO GO MEN SECTION!";
    int choice = getch();
    switch(choice)
    {
    case 8:
        kidsmain();
        break;
    case 27:
        exit(1);
        break;
    }

}
void kid_caps_hats(int a,int b)
{
    system("cls");
    time();
    string mn[4]=
    {
        "PRICE LIST.......",
        "1. JEANS JACKET\t:  Rs 899",
        "2. LEATHER JACKET\t:  Rs 1499",
        "3. HOODIE\t\t:  Rs 699",
        };
        int i=0;
        while(i<4)
    {
        gotoxy(a,b+5+2*i);
        textcolor(GREEN);
        cout<<mn[i]<<endl;
        i++;
    }
    gotoxy(a,b+4*i);
    cout<<"PRESS BACKSPACE TO GO MEN SECTION!";
    int choice = getch();
    switch(choice)
    {
    case 8:
        kidsmain();
        break;
    case 27:
        exit(1);
        break;
    }

}
void kid_BODYSUITS(int a,int b)
{
    system("cls");
    time();
    string mn[4]=
    {
        "PRICE LIST.......",
        "1. CAP\t:  Rs 299",
        "2. GLOVES\t:  Rs 399",
        "3. MUFFLERS\t:  Rs 349",
        };
        int i=0;
        while(i<4)
    {
        gotoxy(a,b+5+2*i);
        textcolor(GREEN);
        cout<<mn[i]<<endl;
        i++;
    }
    gotoxy(a,b+4*i);
    cout<<"PRESS BACKSPACE TO GO MEN SECTION!";
    int choice = getch();
    switch(choice)
    {
    case 8:
        kidsmain();
    case 27:
        exit(1);
        break;
    }
}
void kid_ROMPERS_SLEEPSUITS(int a,int b)
{
    system("cls");
    time();
    string mn[5]=
    {
        "PRICE LIST.......",
        "1. COTTON HALF T-SHIRT\t:  Rs 349",
        "2. NYLON HALF T-SHIRT\t:  Rs 249",
        "3. COTTON FULL T-SHIRT\t:  Rs 399",
        "4. NYLON HALF T-SHIRT\t:  Rs 299"
        };
        int i=0;
        while(i<5)
    {
        gotoxy(a,b+5+2*i);
        textcolor(GREEN);
        cout<<mn[i]<<endl;
        i++;
    }
    gotoxy(a,b-2+4*i);
    cout<<"PRESS BACKSPACE TO GO MEN SECTION!";
    int choice = getch();
    switch(choice)
    {
    case 8:
        kidsmain();
    case 27:
        exit(1);
        break;
    }
}
void kid_CLOTHINGSET(int a,int b)
{
    system("cls");
    time();
    string mn[5]=
    {
        "PRICE LIST.......",
        "1. COTTON SHORTS\t:  Rs 499",
        "2. COTTON PANTS\t:  Rs 999",
        "3. CARGO JEANS\t:  Rs 1299",
        "4. DENIM JEANS\t:  Rs 1499"
        };
        int i=0;
        while(i<5)
    {
        gotoxy(a,b+5+2*i);
        textcolor(GREEN);
        cout<<mn[i]<<endl;
        i++;
    }
    gotoxy(a,b-2+4*i);
    cout<<"PRESS BACKSPACE TO GO MEN SECTION!";
    int choice = getch();
    switch(choice)
    {
    case 8:
        kidsmain();
    case 27:
        exit(1);
        break;
    }
}
Men.cpp
#include<bits/stdc++.h>
#include<fstream>
#include<conio.h>
#include"../conio2.h"
#include"../locTime.h"
#define el cout<<endl;
using namespace std;

int men(int a, int b,string mn[]);
void men_sweater(int a, int b);
void men_jackets_blazers(int a,int b);
void men_CAPS_GLOVES_MUFFLERS(int a,int b);
void men_T_SHIRTS(int a,int b);
void men_SHORTS_PANTS_JEANS(int a,int b);
void men_SHIRTS(int a,int b);
void window1();
void menmain()
{
    string mn[11]=
    {
    "WELCOME TO THE MEN'S SECTION",
    "What would you like to buy? ",
    "###  WINTER COLLECTION  ###",
    "1. SWEATERS",
    "2. JACKETS & BLAZERS",
    "3. CAPS , GLOVES AND MUFFLERS",
    "###  SUMMER COLLECTION  ###",
    "4. T-SHIRTS",
    "5. SHORTS, PANTS & JEANS",
    "6. SHIRTS",
    "0. PREVIOUS MENU",
    };
    int a=68, b=12;
    men(a,b,mn);

}
int men(int a, int b, string mn[])
{
    system("cls");
    time();
    int i=0;
    while(i<11)
    {
        gotoxy(a,b+2*i);
        textcolor(GREEN);
        cout<<mn[i]<<endl;
        i++;
    }
    gotoxy(a,b+22);
    cout<<"ENTER YOUR CHOICE(0 TO 6) : ";
    textbackground(WHITE);
    cout<<"    ";
    textbackground(BLACK);
    int choice;
    gotoxy(a+29,b+22);
    cin>>choice;
    textbackground(BLACK);

    switch(choice)
    {
    case 1:
        men_sweater(a,b);
        break;
    case 2:
        men_jackets_blazers(a,b);
        break;
    case 3:
        men_CAPS_GLOVES_MUFFLERS(a,b);
        break;
    case 4:
        men_T_SHIRTS(a,b);
        break;
    case 5:
        men_SHORTS_PANTS_JEANS(a,b);
        break;
    case 6:
        men_SHIRTS(a,b);
        break;
    case 0:
        window1();
        break;
    default:
        gotoxy(a,b+25);
        cout<<"WRONG INPUT!";
    }

}

void men_sweater(int a,int b)
{
    system("cls");
    time();
    string mn[4]=
    {
        "PRICE LIST.......",
        "1. V NECK\t\t:  Rs 699    ",
        "2. ROUND NECK\t:  Rs 499",
        "3. TURTLE NECK\t:  Rs 799",
        };
        int i=0;
        while(i<4)
    {
        gotoxy(a,b+5+2*i);
        textcolor(GREEN);
        cout<<mn[i]<<endl;
        i++;
    }
    gotoxy(a,b+4*i);
    cout<<"PRESS BACKSPACE TO GO MEN SECTION!";
    int choice = getch();
    switch(choice)
    {
    case 8:
        menmain();
        break;
    case 27:
        exit(1);
        break;
    }

}
void men_jackets_blazers(int a,int b)
{
    system("cls");
    time();
    string mn[4]=
    {
        "PRICE LIST.......",
        "1. JEANS JACKET\t:  Rs 899",
        "2. LEATHER JACKET\t:  Rs 1499",
        "3. HOODIE\t\t:  Rs 699",
        };
        int i=0;
        while(i<4)
    {
        gotoxy(a,b+5+2*i);
        textcolor(GREEN);
        cout<<mn[i]<<endl;
        i++;
    }
    gotoxy(a,b+4*i);
    cout<<"PRESS BACKSPACE TO GO MEN SECTION!";
    int choice = getch();
    switch(choice)
    {
    case 8:
        menmain();
        break;
    case 27:
        exit(1);
        break;
    }

}
void men_CAPS_GLOVES_MUFFLERS(int a,int b)
{
    system("cls");
    time();
    string mn[4]=
    {
        "PRICE LIST.......",
        "1. CAP\t:  Rs 299",
        "2. GLOVES\t:  Rs 399",
        "3. MUFFLERS\t:  Rs 349",
        };
        int i=0;
        while(i<4)
    {
        gotoxy(a,b+5+2*i);
        textcolor(GREEN);
        cout<<mn[i]<<endl;
        i++;
    }
    gotoxy(a,b+4*i);
    cout<<"PRESS BACKSPACE TO GO MEN SECTION!";
    int choice = getch();
    switch(choice)
    {
    case 8:
        menmain();
    case 27:
        exit(1);
        break;
    }
}
void men_T_SHIRTS(int a,int b)
{
    system("cls");
    time();
    string mn[5]=
    {
        "PRICE LIST.......",
        "1. COTTON HALF T-SHIRT\t:  Rs 349",
        "2. NYLON HALF T-SHIRT\t:  Rs 249",
        "3. COTTON FULL T-SHIRT\t:  Rs 399",
        "4. NYLON HALF T-SHIRT\t:  Rs 299"
        };
        int i=0;
        while(i<5)
    {
        gotoxy(a,b+5+2*i);
        textcolor(GREEN);
        cout<<mn[i]<<endl;
        i++;
    }
    gotoxy(a,b-2+4*i);
    cout<<"PRESS BACKSPACE TO GO MEN SECTION!";
    int choice = getch();
    switch(choice)
    {
    case 8:
        menmain();
    case 27:
        exit(1);
        break;
    }
}
void men_SHORTS_PANTS_JEANS(int a,int b)
{
    system("cls");
    time();
    string mn[5]=
    {
        "PRICE LIST.......",
        "1. COTTON SHORTS\t:  Rs 499",
        "2. COTTON PANTS\t:  Rs 999",
        "3. CARGO JEANS\t:  Rs 1299",
        "4. DENIM JEANS\t:  Rs 1499"
        };
        int i=0;
        while(i<5)
    {
        gotoxy(a,b+5+2*i);
        textcolor(GREEN);
        cout<<mn[i]<<endl;
        i++;
    }
    gotoxy(a,b-2+4*i);
    cout<<"PRESS BACKSPACE TO GO MEN SECTION!";
    int choice = getch();
    switch(choice)
    {
    case 8:
        menmain();
    case 27:
        exit(1);
        break;
    }
}
void men_SHIRTS(int a,int b)
{
    system("cls");
    time();
    string mn[5]=
    {
        "PRICE LIST.......",
        "1. COTTON HALF SHIRT\t\t:  Rs 549",
        "2. COTTON FULL SHIRT\t\t:  Rs 699",
        "3. NYLON FULL T-SHIRT\t:  Rs 449",
        "4. NYLON HALF T-SHIRT\t:  Rs 599"
        };
        int i=0;
        while(i<5)
    {
        gotoxy(a,b+5+2*i);
        textcolor(GREEN);
        cout<<mn[i]<<endl;
        i++;
    }
    gotoxy(a,b-2+4*i);
    cout<<"PRESS BACKSPACE TO GO MEN SECTION!";
    int choice = getch();
    switch(choice)
    {
    case 8:
        menmain();
    case 27:
        exit(1);
        break;
    }
}
Women.cpp
#include<bits/stdc++.h>
#include<fstream>
#include<conio.h>
#include"../conio2.h"
#include"../locTime.h"
#define el cout<<endl;
using namespace std;

int women(int a, int b, string mn[]);

void women_sweater(int a,int b);
void women_jackets(int a,int b);
void women_CAPS_GLOVES_MUFFLERS(int a,int b);
void women_TOPS_JEANS(int a,int b);
void women_SAREES(int a,int b);
void women_SALWARSUITS_KURTIS(int a,int b);
void women_WESTERNS(int a,int b);

void window1();
void womenmain()
{
    string mn[12]=
    {
    "WELCOME TO THE WOMEN'S SECTION",
    "What would you like to buy? ",
    "###  WINTER COLLECTION  ###",
    "1. SWEATERS",
    "2. JACKETS",
    "3. CAPS , GLOVES AND SHAWL",
    "###  SUMMER COLLECTION  ###",
    "4. TOPS & JEANS",
    "5. SAREES",
    "6. SALWAR SUITS & KURTIS",
    "7. WESTERNS",
    "0. PREVIOUS MENU",
    };
    int a=68, b=12;
    women(a,b,mn);

}
int women(int a, int b, string mn[])
{
    system("cls");
    time();
    int i=0;
    while(i<12)
    {
        gotoxy(a,b+2*i);
        textcolor(GREEN);
        cout<<mn[i]<<endl;
        i++;
    }
    gotoxy(a,b+24);
    cout<<"ENTER YOUR CHOICE(0 TO 7) : ";
    textbackground(WHITE);
    cout<<"    ";
    textbackground(BLACK);
    int choice;
    gotoxy(a+29,b+24);
    cin>>choice;
    textbackground(BLACK);
    switch(choice)
    {
    case 1:
        women_sweater(a,b);
        break;
    case 2:
        women_jackets(a,b);
        break;
    case 3:
        women_CAPS_GLOVES_MUFFLERS(a,b);
        break;
    case 4:
        women_TOPS_JEANS(a,b);
        break;
    case 5:
        women_SAREES(a,b);
        break;
    case 6:
        women_SALWARSUITS_KURTIS(a,b);
        break;
    case 7:
        women_WESTERNS(a,b);
        break;
    case 0:
        window1();
        break;
    default:
        gotoxy(a,b+27);
        cout<<"WRONG INPUT!";
    }

}

void women_sweater(int a,int b)
{
    system("cls");
    time();
    string mn[5]=
    {
        "PRICE LIST.......",
        "1. POLO NECK\t:  Rs 1099",
        "2. CARDIGAN\t:  Rs 1499",
        "3. WOOLEN PULL-OVER SWEATER\t:  Rs 999",
        "4. THERMAL\t:  Rs 799",
        };
        int i=0;
        while(i<5)
    {
        gotoxy(a,b+5+2*i);
        textcolor(GREEN);
        cout<<mn[i]<<endl;
        i++;
    }
    gotoxy(a,b+3+3*i);
    cout<<"PRESS BACKSPACE TO GO MEN SECTION!";
    int choice = getch();
    switch(choice)
    {
    case 8:
        womenmain();
        break;
    case 27:
        exit(1);
        break;
    }

}
void women_jackets(int a,int b)
{
    system("cls");
    time();
    string mn[4]=
    {
        "PRICE LIST.......",
        "1. JEANS JACKET\t:  Rs 999    ",
        "2. LEATHER JACKET\t:  Rs 1599",
        "3. HOODIE\t:  Rs 799",
        };
        int i=0;
        while(i<4)
    {
        gotoxy(a,b+5+2*i);
        textcolor(GREEN);
        cout<<mn[i]<<endl;
        i++;
    }
    gotoxy(a,b+4*i);
    cout<<"PRESS BACKSPACE TO GO MEN SECTION!";
    int choice = getch();
    switch(choice)
    {
    case 8:
        womenmain();
        break;
    case 27:
        exit(1);
        break;
    }

}
void women_CAPS_GLOVES_MUFFLERS(int a,int b)
{
    system("cls");
    time();
    string mn[4]=
    {
        "PRICE LIST.......",
        "1. CAP\t:  Rs 299",
        "2. GLOVES\t:  Rs 399",
        "3. SHAWLS\t:  Rs 1399",
        };
        int i=0;
        while(i<4)
    {
        gotoxy(a,b+5+2*i);
        textcolor(GREEN);
        cout<<mn[i]<<endl;
        i++;
    }
    gotoxy(a,b+4*i);
    cout<<"PRESS BACKSPACE TO GO MEN SECTION!";
    int choice = getch();
    switch(choice)
    {
    case 8:
        womenmain();
    case 27:
        exit(1);
        break;
    }
}
void women_TOPS_JEANS(int a,int b)
{
    system("cls");
    time();
    string mn[5]=
    {
        "PRICE LIST.......",
        "1. COTTON TOP\t:  Rs 399",
        "2. CROP TOP\t:  Rs 299",
        "3. FULL SLEEVE TOP\t:  Rs 349",
        "4. DENIM JEANS\t:  Rs 999"
        };
        int i=0;
        while(i<5)
    {
        gotoxy(a,b+5+2*i);
        textcolor(GREEN);
        cout<<mn[i]<<endl;
        i++;
    }
    gotoxy(a,b-2+4*i);
    cout<<"PRESS BACKSPACE TO GO MEN SECTION!";
    int choice = getch();
    switch(choice)
    {
    case 8:
        womenmain();
    case 27:
        exit(1);
        break;
    }
}
void women_SAREES(int a,int b)
{
    system("cls");
    time();
    string mn[6]=
    {
        "PRICE LIST.......",
        "1. COTTON SAREES\t:  Rs 1499",
        "2. SYNTHETIC SAREES\t:  Rs 999",
        "3. SILK SAREES\t:  Rs 2999",
        "4. DENIM JEANS\t:  Rs 1499",
        "5. KANJIVARAM SAREES\t:  Rs 3999"
        };
        int i=0;
        while(i<6)
    {
        gotoxy(a,b+5+2*i);
        textcolor(GREEN);
        cout<<mn[i]<<endl;
        i++;
    }
    gotoxy(a,b-4+4*i);
    cout<<"PRESS BACKSPACE TO GO MEN SECTION!";
    int choice = getch();
    switch(choice)
    {
    case 8:
        womenmain();
    case 27:
        exit(1);
        break;
    }
}
void women_SALWARSUITS_KURTIS(int a,int b)
{
    system("cls");
    time();
    string mn[6]=
    {
        "PRICE LIST.......",
        "1. PATIALA SALWAR SUITS\t:  Rs 799",
        "2. ANARKALI FROCK\t:  Rs 1499",
        "3. PALAZZO SALWAR SUITS\t:  Rs 949",
        "4. LONG STRAIGHT KURTIS\t:  Rs 599",
        "5. ANARKALI KURTIS\t:  Rs 699"
        };
        int i=0;
        while(i<6)
    {
        gotoxy(a,b+5+2*i);
        textcolor(GREEN);
        cout<<mn[i]<<endl;
        i++;
    }
    gotoxy(a,b-4+4*i);
    cout<<"PRESS BACKSPACE TO GO MEN SECTION!";
    int choice = getch();
    switch(choice)
    {
    case 8:
        womenmain();
    case 27:
        exit(1);
        break;
    }
}
void women_WESTERNS(int a,int b)
{
    system("cls");
    time();
    string mn[6]=
    {
        "PRICE LIST.......",
        "1. ONE PIECE\t:  Rs 1299",
        "2. DANGRI\t:  Rs 1199",
        "3. COCKTAIL DRESSES\t:  Rs 1499",
        "4. WRAP DRESSES\t:  Rs 1699",
        "5. SLIP DRESSES\t:  Rs 2099"
        };
        int i=0;
        while(i<6)
    {
        gotoxy(a,b+5+2*i);
        textcolor(GREEN);
        cout<<mn[i]<<endl;
        i++;
    }
    gotoxy(a,b-4+4*i);
    cout<<"PRESS BACKSPACE TO GO MEN SECTION!";
    int choice = getch();
    switch(choice)
    {
    case 8:
        womenmain();
    case 27:
        exit(1);
        break;
    }
}

time.cpp
#include<bits/stdc++.h>
#include<ctime>
#include<conio.h>
#include"../conio2.h"

using namespace std;

void time()
{

  time_t tt;
  struct tm *ti;
  time(&tt);
  ti = localtime(&tt);
  textbackground(GREEN);
  textcolor(WHITE);
  cout<<" DATE & TIME : "<<asctime(ti);
  textbackground(BLACK);
}
window size and position.cpp
#include <iostream>
#include <fstream>
#include <windows.h>
#include <cwchar>
#include <ctime>
#include <conio.h>
#include"../conio2.h"

#define _WIN32_WINNT 0x0500

void MoveWindowSize(int posx, int posy, int x, int y)
{
    RECT rectClient, rectWindow, ConsoleRect;
    HWND hWnd = GetConsoleWindow();
    GetClientRect(hWnd, &rectClient);
    GetWindowRect(hWnd, &rectWindow);
    MoveWindow(hWnd, posx, posy, rectClient.right - rectClient.left, rectClient.bottom - rectClient.top, TRUE);
    HWND console = GetConsoleWindow();
    GetWindowRect(console, &ConsoleRect);
    MoveWindow(console, ConsoleRect.left, ConsoleRect.top, x, y, TRUE);
    HWND consoleWindow = GetConsoleWindow();
    SetWindowLong(consoleWindow, GWL_STYLE, GetWindowLong(consoleWindow, GWL_STYLE) & ~WS_MAXIMIZEBOX & ~WS_SIZEBOX);
}
Windowsize.cpp
#include<bits/stdc++.h>
#include<windows.h>
#define _WIN32_WINNT 0x0500
using namespace std;
void window_size()
{
	HWND console = GetConsoleWindow();
	RECT ConsoleRect;
	GetWindowRect(console, &ConsoleRect);
    MoveWindow(console, ConsoleRect.left, ConsoleRect.top, 1000, 1000, TRUE);
    HWND consoleWindow = GetConsoleWindow();
    SetWindowLong(consoleWindow, GWL_STYLE, GetWindowLong(consoleWindow, GWL_STYLE) & ~WS_MAXIMIZEBOX & ~WS_SIZEBOX);
}
conio.c
/* A conio implementation for Mingw/Dev-C++.
 *
 * Written by:
 * Hongli Lai <hongli@telekabel.nl>
 * tkorrovi <tkorrovi@altavista.net> on 2002/02/26.
 * Andrew Westcott <ajwestco@users.sourceforge.net>
 * Michal Molhanec <michal@molhanec.net>
 *
 * Offered for use in the public domain without any warranty.
 *
 */

#include <stdio.h>
#include <stdlib.h>
//#include <unistd.h>
#include <windows.h>
#include <string.h>
#include "../conio2.h"

#ifdef __cplusplus
extern "C" {
#endif

static int __BACKGROUND = BLACK;
static int __FOREGROUND = LIGHTGRAY;
static struct text_info __text_info = {
    1, 1,
    LIGHTGRAY + (BLACK << 4),
    LIGHTGRAY + (BLACK << 4),
    80, 25
};
static int __CONIO_TOP = 0;
static int __CONIO_LEFT = 0;

static void
__fill_text_info (void)
{
    CONSOLE_SCREEN_BUFFER_INFO info;

    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &info);
    __CONIO_LEFT = info.srWindow.Left;
    __CONIO_TOP = info.srWindow.Top;
    __text_info.curx = info.dwCursorPosition.X - __CONIO_LEFT + 1;
    __text_info.cury = info.dwCursorPosition.Y - __CONIO_TOP  + 1;
    __text_info.attribute = info.wAttributes;
    __text_info.screenwidth  = info.srWindow.Right - info.srWindow.Left + 1;
    __text_info.screenheight = info.srWindow.Bottom - info.srWindow.Top + 1;
}

void
gettextinfo (struct text_info * info)
{
    __fill_text_info();
    *info = __text_info;
}

void
inittextinfo (void)
{
    CONSOLE_SCREEN_BUFFER_INFO info;

    GetConsoleScreenBufferInfo (GetStdHandle(STD_OUTPUT_HANDLE), &info);
    __text_info.normattr = info.wAttributes;
}

void
clrscr (void)
{
    DWORD written;
    int i;

    __fill_text_info();
    for (i = __CONIO_TOP; i < __CONIO_TOP + __text_info.screenheight; i++) {
      FillConsoleOutputAttribute (GetStdHandle (STD_OUTPUT_HANDLE),
        __FOREGROUND + (__BACKGROUND << 4), __text_info.screenwidth,
        (COORD) {__CONIO_LEFT, i},
        &written);
      FillConsoleOutputCharacter (GetStdHandle(STD_OUTPUT_HANDLE), ' ',
        __text_info.screenwidth,
        (COORD) {__CONIO_LEFT, i},
        &written);
    }
    gotoxy (1, 1);
}


void
clreol (void)
{
    COORD coord;
    DWORD written;

    __fill_text_info();
    coord.X = __CONIO_LEFT + __text_info.curx - 1;
    coord.Y = __CONIO_TOP  + __text_info.cury - 1;

    FillConsoleOutputAttribute (GetStdHandle (STD_OUTPUT_HANDLE),
      __FOREGROUND + (__BACKGROUND << 4),
      __text_info.screenwidth - __text_info.curx + 1, coord, &written);
    FillConsoleOutputCharacter (GetStdHandle (STD_OUTPUT_HANDLE),
      ' ', __text_info.screenwidth - __text_info.curx + 1, coord, &written);
    gotoxy (__text_info.curx, __text_info.cury);
}


void
delline (void)
{
    COORD coord;
    SMALL_RECT rect;
    CHAR_INFO fillchar;

    __fill_text_info();
    coord.X = __CONIO_LEFT;
    coord.Y = __CONIO_TOP + __text_info.cury - 1;
    rect.Left = __CONIO_LEFT;
    rect.Top = __CONIO_TOP + __text_info.cury;
    rect.Right = __CONIO_LEFT + __text_info.screenwidth - 1;
    rect.Bottom = __CONIO_TOP + __text_info.screenheight - 1;
    fillchar.Attributes = __FOREGROUND + (__BACKGROUND << 4);
#ifdef UNICODE
    fillchar.Char.UnicodeChar = L' ';
    ScrollConsoleScreenBufferW (GetStdHandle (STD_OUTPUT_HANDLE),
      &rect, NULL, coord, &fillchar);
#else
    fillchar.Char.AsciiChar = ' ';
    ScrollConsoleScreenBufferA (GetStdHandle (STD_OUTPUT_HANDLE),
      &rect, NULL, coord, &fillchar);
#endif


    gotoxy (__text_info.curx, __text_info.cury);
}

void
insline (void)
{
    COORD coord;
    SMALL_RECT rect;
    CHAR_INFO fillchar;

    __fill_text_info();
    coord.X = __CONIO_LEFT;
    coord.Y = __CONIO_TOP + __text_info.cury;
    rect.Left = __CONIO_LEFT;
    rect.Top = __CONIO_TOP + __text_info.cury - 1;
    rect.Right = __CONIO_LEFT + __text_info.screenwidth - 1;
    rect.Bottom = __CONIO_TOP + __text_info.screenheight - 2;
    fillchar.Attributes = __FOREGROUND + (__BACKGROUND << 4);
#ifdef UNICODE
    fillchar.Char.UnicodeChar = L' ';
    ScrollConsoleScreenBufferW (GetStdHandle (STD_OUTPUT_HANDLE),
      &rect, NULL, coord, &fillchar);
#else
    fillchar.Char.AsciiChar = ' ';
    ScrollConsoleScreenBufferA (GetStdHandle (STD_OUTPUT_HANDLE),
      &rect, NULL, coord, &fillchar);
#endif

    gotoxy (__text_info.curx, __text_info.cury);
}

void
movetext (int left, int top, int right, int bottom, int destleft, int desttop)
{
    struct char_info * buffer;

    buffer = malloc ((right - left + 1) * (bottom - top + 1) * sizeof(struct char_info));
    gettext (left, top, right, bottom, buffer);
    puttext (destleft, desttop, destleft + right - left, desttop + bottom - top, buffer);
    free(buffer);
}

void
_conio_gettext (int left, int top, int right, int bottom,
  struct char_info * buf)
{
    int i;
    SMALL_RECT r;
    CHAR_INFO* buffer;
    COORD size;

    __fill_text_info();
    r = (SMALL_RECT) {__CONIO_LEFT + left - 1, __CONIO_TOP + top - 1,
      __CONIO_LEFT + right - 1, __CONIO_TOP + bottom - 1};
    size.X = right - left + 1;
    size.Y = bottom - top + 1;
    buffer = malloc (size.X * size.Y * sizeof(CHAR_INFO));

    ReadConsoleOutput (GetStdHandle (STD_OUTPUT_HANDLE),
      (PCHAR_INFO) buffer, size, (COORD) {0, 0}, &r);

    for (i = 0; i < size.X * size.Y; i++)
    {
#ifdef UNICODE
        buf[i].letter = buffer[i].Char.UnicodeChar;
#else
        buf[i].letter = buffer[i].Char.AsciiChar;
#endif
        buf[i].attr = buffer[i].Attributes;
    }
    free (buffer);
}

void
puttext (int left, int top, int right, int bottom, struct char_info * buf)
{
    int i;
    SMALL_RECT r;
    CHAR_INFO* buffer;
    COORD size;

    __fill_text_info();
    r = (SMALL_RECT) {__CONIO_LEFT + left - 1, __CONIO_TOP + top - 1,
      __CONIO_LEFT + right - 1, __CONIO_TOP + bottom - 1};
    size.X = right - left + 1;
    size.Y = bottom - top + 1;
    buffer = malloc (size.X * size.Y * sizeof(CHAR_INFO));

    for (i = 0; i < size.X * size.Y; i++)
    {
#ifdef UNICODE
        buffer[i].Char.UnicodeChar = buf[i].letter;
#else
        buffer[i].Char.AsciiChar = buf[i].letter;
#endif
        buffer[i].Attributes = buf[i].attr;
    }

    WriteConsoleOutput (GetStdHandle (STD_OUTPUT_HANDLE),
      buffer, size, (COORD) {0, 0}, &r);
    free (buffer);
}

void
gotoxy(int x, int y)
{
  COORD c;

  c.X = __CONIO_LEFT + x - 1;
  c.Y = __CONIO_TOP  + y - 1;
  SetConsoleCursorPosition (GetStdHandle(STD_OUTPUT_HANDLE), c);
}

void
cputsxy (int x, int y, char * str)
{
    gotoxy (x, y);
    cputs (str);
}

void
putchxy (int x, int y, char ch)
{
    gotoxy (x, y);
    putch (ch);
}

void
_setcursortype (int type)
{
    CONSOLE_CURSOR_INFO Info;

    if (type == 0) {
        Info.bVisible = FALSE;
    } else {
      Info.dwSize = type;
      Info.bVisible = TRUE;
    }
    SetConsoleCursorInfo (GetStdHandle (STD_OUTPUT_HANDLE),
      &Info);
}


void
textattr (int _attr)
{
    __FOREGROUND = _attr & 0xF;
    __BACKGROUND = _attr >> 4;
    SetConsoleTextAttribute (GetStdHandle(STD_OUTPUT_HANDLE), _attr);
}

void
normvideo (void)
{
    textattr (__text_info.normattr);
}

void
textbackground (int color)
{
    __BACKGROUND = color;
    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE),
      __FOREGROUND + (color << 4));
}


void
textcolor (int color)
{
    __FOREGROUND = color;
    SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE),
      color + (__BACKGROUND << 4));
}


int
wherex (void)
{
    __fill_text_info();
    return __text_info.curx;
}


int
wherey (void)
{
    __fill_text_info();
    return __text_info.cury;
}

char *
getpass (const char * prompt, char * str)
{
    int maxlength = str[0];
    int length = 0;
    int ch = 0;
    int x, y;

    cputs(prompt);
    __fill_text_info();
    x = __text_info.curx;
    y = __text_info.cury;

    while (ch != '\r') {
        ch = getch();
        switch (ch) {
            case '\r' : /* enter */
                break;
            case '\b' : /* backspace */
                if (length > 0) putchxy (x + --length, y, ' ');
                gotoxy (x + length, y);
                break;
            default:
                if (length < maxlength) {
                    putchxy (x + length, y, '*');
                    str[2 + length++] = ch;
                }
        }
    }

    str[1] = length;
    str[2 + length] = '\0';
    return &str[2];
}

void
highvideo (void)
{
    if (__FOREGROUND < DARKGRAY) textcolor(__FOREGROUND + 8);
}

void
lowvideo (void)
{
    if (__FOREGROUND > LIGHTGRAY) textcolor(__FOREGROUND - 8);
}

void
delay (int ms)
{
    Sleep(ms);
}

void
switchbackground (int color)
{
    struct char_info* buffer;
    int i;

    buffer = malloc(__text_info.screenwidth * __text_info.screenheight *
      sizeof(struct char_info));
    _conio_gettext(1, 1, __text_info.screenwidth, __text_info.screenheight,
      buffer);
    for (i = 0; i < __text_info.screenwidth * __text_info.screenheight; i++) {
        unsigned short attr = buffer[i].attr & 0xF;
        buffer[i].attr = (color << 4) | attr;
    }
    puttext(1, 1, __text_info.screenwidth, __text_info.screenheight, buffer);
    free(buffer);
}

void
flashbackground (int color, int ms)
{
    struct char_info* buffer;

    buffer = malloc(__text_info.screenwidth * __text_info.screenheight *
      sizeof(struct char_info));
    _conio_gettext(1, 1, __text_info.screenwidth, __text_info.screenheight,
      buffer);
    switchbackground(color);
    delay(ms);
    puttext(1, 1, __text_info.screenwidth, __text_info.screenheight, buffer);
    free(buffer);
}

void
clearkeybuf (void)
{
    while (kbhit()) {
        getch();
    }
}

#ifdef __cplusplus
}
#endif

conio2.h
/** @file conio2.h
 * A conio implementation for Mingw/Dev-C++.
 *
 * Written by:
 * Hongli Lai <hongli@telekabel.nl>
 * tkorrovi <tkorrovi@altavista.net> on 2002/02/26.
 * Andrew Westcott <ajwestco@users.sourceforge.net>
 * Michal Molhanec <michal@molhanec.net>
 *
 * Offered for use in the public domain without any warranty.
 */

#ifndef _CONIO2_H_
#define _CONIO2_H_

#include <conio.h>
#ifdef UNICODE
    #include <windows.h>    // we need wchar_t
#endif

#ifdef __cplusplus
extern "C" {
#endif

/**
 * Colors which you can use in your application.
 */
typedef enum
{
    BLACK,          /**< black color */
    BLUE,           /**< blue color */
    GREEN,          /**< green color */
    CYAN,           /**< cyan color */
    RED,            /**< red color */
    MAGENTA,        /**< magenta color */
    BROWN,          /**< brown color */
    LIGHTGRAY,      /**< light gray color */
    DARKGRAY,       /**< dark gray color */
    LIGHTBLUE,      /**< light blue color */
    LIGHTGREEN,     /**< light green color */
    LIGHTCYAN,      /**< light cyan color */
    LIGHTRED,       /**< light red color */
    LIGHTMAGENTA,   /**< light magenta color */
    YELLOW,         /**< yellow color */
    WHITE           /**< white color */
} COLORS;

/*@{*/
/**
 * This defines enables you to use all MinGW conio.h functions without
 * underscore.
 */
#define cgets   _cgets
#define cprintf _cprintf
#define cputs   _cputs
#define cscanf  _cscanf

#ifdef UNICODE
    #define cgetws   _cgetws
    #define getwch   _getwch
    #define getwche  _getwche
    #define putwch   _putwch
    #define ungetwch _ungetwch
    #define cputws   _cputws
    #define cwprintf _cwprintf
    #define cwscanf  _cwscanf
#endif
/*@}*/

/**
 * Define alias for _conio_gettext.
 * If you want to use gettext function from some other library
 * (e.g. GNU gettext) you have to define _CONIO_NO_GETTEXT_ so you won't get
 * name conflict.
 */
#ifndef _CONIO_NO_GETTEXT_
  #define gettext _conio_gettext
#endif

#define ScreenClear clrscr

/**
 * @anchor cursortypes
 * @name Cursor types
 * Predefined cursor types. */
/*@{*/
#define _NOCURSOR 0         /**< no cursor */
#define _SOLIDCURSOR 100    /**< cursor filling whole cell */
#define _NORMALCURSOR 20    /**< cursor filling 20 percent of cell height */
/*@}*/

/**
 * Structure holding information about screen.
 * @see gettextinfo
 * @see inittextinfo
 */
struct text_info {
    unsigned char curx;          /**< cursor coordinate x */
    unsigned char cury;          /**< cursor coordinate y */
    unsigned short attribute;    /**< current text attribute */
    unsigned short normattr;     /**< original value of text attribute after
                                      start of the application. If you don't
                                      called the <TT>inittextinfo</TT> on the
                                      beginning of the application, this always
                                      will be black background and light gray
                                      foreground */
    unsigned char screenwidth;   /**< screen width */
    unsigned char screenheight;  /**< screen height */
};

/**
 * Structure used by gettext/puttext.
 * @see _conio_gettext
 * @see puttext
 */
struct char_info {
#ifdef UNICODE
    wchar_t letter;        /**< character value */
#else
    char letter;           /**< character value */
#endif
    unsigned short attr;   /**< attribute value */
};

/**
 * Returns information of the screen.
 * @see text_info
 */
void gettextinfo (struct text_info * info);

/**
 * Call this if you need real value of normattr attribute in the text_info
 * structure.
 * @see text_info
 */
void inittextinfo (void);

/**
 * Clears rest of the line from cursor position to the end of line without
 * moving the cursor.
 */
void clreol (void);

/**
 * Clears whole screen.
 */
void clrscr (void);

/**
 * Delete the current line (line on which is cursor) and then moves all lines
 * below one line up. Lines below the line are moved one line up.
 */
void delline (void);

/**
 * Insert blank line at the cursor position.
 * Original content of the line and content of lines below moves one line down.
 * The last line is deleted.
 */
void insline (void);

/**
 * Gets text from the screen. If you haven't defined <TT>_CONIO_NO_GETTEXT_</TT>
 * prior to including <TT>conio2.h</TT> you can use this function also under
 * the <TT>gettext</TT> name.
 * @see char_info
 * @see puttext
 * @param left Left coordinate of the rectangle, inclusive, starting from 1.
 * @param top Top coordinate of the rectangle, inclusive, starting from 1.
 * @param right Right coordinate of the rectangle, inclusive, starting from 1.
 * @param bottom Bottom coordinate of the rectangle, inclusive, starting from 1.
 * @param buf You have to pass buffer of size
 * <TT>(right - left + 1) * (bottom - top + 1) * sizeof(char_info)</TT>.
 */
void _conio_gettext (int left, int top, int right, int bottom,
                     struct char_info * buf);

/**
 * Puts text back to the screen.
 * @see char_info
 * @see _conio_gettext
 * @param left Left coordinate of the rectangle, inclusive, starting from 1.
 * @param top Top coordinate of the rectangle, inclusive, starting from 1.
 * @param right Right coordinate of the rectangle, inclusive, starting from 1.
 * @param bottom Bottom coordinate of the rectangle, inclusive, starting from 1.
 * @param buf You have to pass buffer of size
 * <TT>(right - left + 1) * (bottom - top + 1) * sizeof(char_info)</TT>.
 */
void puttext (int left, int top, int right, int bottom, struct char_info * buf);

/**
 * Copies text.
 * @param left Left coordinate of the rectangle, inclusive, starting from 1.
 * @param top Top coordinate of the rectangle, inclusive, starting from 1.
 * @param right Right coordinate of the rectangle, inclusive, starting from 1.
 * @param bottom Bottom coordinate of the rectangle, inclusive, starting from 1.
 * @param destleft Left coordinate of the destination rectangle.
 * @param desttop Top coordinate of the destination rectangle.
 */
void movetext (int left, int top, int right, int bottom, int destleft,
              int desttop);

/**
 * Moves cursor to the specified position.
 * @param x horizontal position
 * @param y vertical position
 */
void gotoxy(int x, int y);

/**
 * Puts string at the specified position.
 * @param x horizontal position
 * @param y vertical position
 * @param str string
 */
void cputsxy (int x, int y, char * str);

/**
 * Puts char at the specified position.
 * @param x horizontal position
 * @param y vertical position
 * @param ch char
 */
void putchxy (int x, int y, char ch);

/**
 * Sets the cursor type.
 * @see @ref cursortypes
 * @param type cursor type, under Win32 it is height of the cursor in percents
 */
void _setcursortype (int type);

/**
 * Sets attribute of text.
 * @param _attr new text attribute
 */
void textattr (int _attr);

/**
 * Sets text attribute back to value it had after program start.
 * It uses text_info's normattr value.
 * @see text_info
 */
void normvideo (void);

/**
 * Sets text background color.
 * @see COLORS
 * @param color new background color
 */
void textbackground (int color);

/**
 * Sets text foreground color.
 * @see COLORS
 * @param color new foreground color
 */
void textcolor (int color);

/**
 * Reads the cursor X position.
 * @returns cursor X position
 */
int wherex (void);

/**
 * Reads the cursor Y position.
 * @returns cursor Y position
 */
int wherey (void);

/**
 * Reads password. This function behaves like cgets.
 *
 * @see cgets
 * @param prompt prompt which will be displayed to user
 * @param str string for the password. <TT>str[0]</TT> have to contain
 * length of the <TT>str</TT> - 3
 * @returns <TT>&str[2]</TT>, the password will be stored in <TT>str</TT>
 * beginning at <TT>str[2]</TT>, in <TT>str[1]</TT> will be length of the
 * string without <TT>\\0</TT>, at <TT>str[2 + str[1]]</TT> will be \\0.
 */
char * getpass (const char * prompt, char * str);

/**
 * Makes foreground colors light.
 * If the current foreground color is less than <TT>DARKGRAY</TT> adds
 * 8 to the its value making dark colors light.
 * @see COLORS
 * @see lowvideo
 */
void highvideo (void);

/**
 * Makes foreground colors dark.
 * If the current foreground color is higher than <TT>LIGHTGRAY</TT> substracts
 * 8 from its value making light colors dark.
 * @see COLORS
 * @see highvideo
 */
void lowvideo (void);

/*@{*/
/*
 * You may need to link with libmsvcr70.a or libmsvcr70d.a or libmsvcr71.a
 *  or libmsvcr71d.a if you want any of these functions.
 */
#ifdef UNICODE
_CRTIMP wchar_t * __cdecl         _cgetws(wchar_t *);
_CRTIMP unsigned short __cdecl    _getwch(void);
_CRTIMP unsigned short __cdecl    _getwche(void);
_CRTIMP unsigned short __cdecl    _putwch(wchar_t);
_CRTIMP unsigned short __cdecl    _ungetwch(unsigned short);
_CRTIMP int __cdecl               _cputws(const wchar_t *);
_CRTIMP int __cdecl               _cwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl               _cwscanf(const wchar_t *, ...);
#endif
/*@}*/

/**
 * Pauses program execution for a given time.
 * @see switchbackground
 * @param ms miliseconds
 */
void delay (int ms);

/**
 * Replaces background color in the whole window. The text however
 * is left intact. Does not modify textbackground().
 * @see flashbackground
 * @param color background color
 */
void switchbackground (int color);

/**
 * Changes background color for a given time and then it restores it back.
 * You can use it for visual bell. Does not modify textbackground().
 * @see switchbackground
 * @see delay
 * @param color background color
 * @param ms miliseconds
 */
void flashbackground (int color, int ms);

/**
 * Clears the keyboard buffer.
 * To see it in effect run <TT>conio_test</TT> and try to press a key during
 * the 'Flashing...' phase.
 */
void clearkeybuf (void);

#ifdef __cplusplus
}
#endif

#endif /* _CONIO2_H_ */


kids_section.h
#ifndef KIDS_SECTION_H_INCLUDED
#define KIDS_SECTION_H_INCLUDED

void kidsmain();

#endif // KIDS_SECTION_H_INCLUDED
men_section.h
#ifndef MEN_SECTION_H_INCLUDED
#define MEN_SECTION_H_INCLUDED

void menmain();

#endif // MEN_SECTION_H_INCLUDED
women_section.h
#ifndef WOMEN_SECTION_H_INCLUDED
#define WOMEN_SECTION_H_INCLUDED

void womenmain();

#endif // WOMEN_SECTION_H_INCLUDED
locTime.h
#ifndef LOCTIME_H_INCLUDED
#define LOCTIME_H_INCLUDED

void time();

#endif // LOCTIME_H_INCLUDED


window_size.h
#ifndef WINDOW_SIZE_H_INCLUDED
#define WINDOW_SIZE_H_INCLUDED

void window_size();

#endif // WINDOW_SIZE_H_INCLUDED
windowms.h
#ifndef WINDOWMS_H_INCLUDED
#define WINDOWMS_H_INCLUDED

void MoveWindowSize(int posx, int posy, int x, int y);

#endif // WINDOWMS_H_INCLUDED



# 11.Testing :-
	Team Interaction	
The following describes the level of team interaction necessary to have a successful product.
-	The Test Team will work closely with the Development Team to achieve a high quality design and user interface specifications based on customer requirements.  The Test Team is responsible for visualizing test cases and raising quality issues and concerns during meetings to address issues early enough in the development cycle.  
-	The Test Team will work closely with Development Team to determine whether or not the application meets standards for completeness.  If an area is not acceptable for testing, the code complete date will be pushed out, giving the developers additional time to stabilize the area.  
-	Since the application interacts with a back-end system component, the Test Team will need to include a plan for integration testing.  Integration testing must be executed successfully prior to system testing.
	Test Objective
The objective our test plan is to find and report as many bugs as possible to improve the integrity of our program.   Although exhaustive testing is not possible, we will exercise a broad range of tests to achieve our goal.  We will be testing a Binary Search Tree Application utilizing a pre-order traversal format.  There will be eight key functions used to manage our application: load, store, clear, search, insert, delete, list in ascending order, and list in descending order.  Our user interface to utilize these functions is designed to be user-friendly and provide easy manipulation of the tree. The application will only be used as a demonstration tool, but we would like to ensure that it could be run from a variety of platforms with little impact on performance or usability.
	Process Overview
The following represents the overall flow of the testing process:
Identify the requirements to be tested. All test cases shall be derived using the current Program Specification.
1.	Identify which particular test(s) will be used to test each module. 
2.	Review the test data and test cases to ensure that the unit has been thoroughly verified and that the test data and test cases are adequate to verify proper operation of the unit. 
3.	Identify the expected results for each test. 
4.	Document the test case configuration, test data, and expected results. 
5.	Perform the test(s). 
6.	Document the test data, test cases, and test configuration used during the testing process. This information shall be submitted via the Unit/System Test Report .
7.	Successful unit testing is required before the unit is eligible for component integration/system testing. 
8.	Unsuccessful testing requires a Bug Report Form to be generated. This document shall describe the test case, the problem encountered, its possible cause, and the sequence of events that led to the problem. It shall be used as a basis for later technical analysis. 
9.	Test documents and reports shall be submitted. Any specifications to be reviewed, revised, or updated shall be handled immediately.
	Testing Process
 
The diagram above outlines the Test Process approach that will be followed. 
organize Project involves creating a System Test Plan, Schedule & Test Approach, and assigning responsibilities.

a.Design/Build System Test involves identifying Test Cycles, Test Cases, Entrance & Exit Criteria, Expected Results, etc. In general, test conditions/expected results will be identified by the Test Team in conjunction with the Development Team.  The Test Team will then identify Test Cases and the Data required. The Test conditions are derived from the Program Specifications Document.

b. Design/Build Test Procedures includes setting up procedures such as Error Management systems and Status reporting.

c. Build Test Environment includes requesting/building hardware, software and data set-ups.

e. Execute System Tests – The tests identified in the Design/Build Test Procedures will be executed.  All results will be documented and Bug Report Forms filled out and given to the Development Team as necessary.

f. Signoff - Signoff happens when all pre-defined exit criteria have been achieved. 

	Testing Strategy
The following outlines the types of testing that will be done for unit, integration, and system testing.  While it includes what will be tested, the specific use cases that determine how the testing is done will be detailed in the Test Design Document.  The test cases that will be used for designing use cases is shown in Figure 2.1 and onwards.
	Test Cases:

Tested By:	Somnath Bhadra
Test Type	Unit Testing
Test Case Number	1
Test Case Name	User Identification
Test Case Description 	The user should enter his/ her accurate user id and password so that he/she can able to go for the further options. The test case will check the application for the same since a user can only login with the correct user id , password.
Item(s) to be tested
1	Verification of the user id and password with the record in the database.
Specifications

Input	Expected
Output/Result
1)	Correct User id and password

2)	Incorrect Id or Password            	1)	Successful login

2)	Failure Message



	Unit Testing :-
Unit Testing is done at the source or code level for language-specific programming errors such as bad syntax, logic errors, or to test particular functions or code modules.  The unit test cases shall be designed to test the validity of the programs correctness.  

-	White Box Testing
In white box testing, the UI is bypassed.  Inputs and outputs are tested directly at the code level and the results are compared against specifications. This form of testing ignores the function of the program under test and will focus only on its code and the structure of that code. Test case designers shall generate cases that not only cause each condition to take on all possible values at least once, but that cause each such condition to be executed at least once.  To ensure this happens, we will be applying Branch Testing.  Because the functionality of the program is relatively simple, this method will be feasible to apply.
Each function of the binary tree repository is executed independently; therefore, a program flow for each function has been derived from the code.

-	Black Box Testing
Black box testing typically involves running through every possible input to verify that it results in the right outputs using the software as an end-user would.  We have decided to perform Equivalence Partitioning and Boundary Value Analysis testing on our application.  
	System Testing :-
The goals of system testing are to detect faults that can only be exposed by testing the entire integrated system or some major part of it. Generally, system testing is mainly concerned with areas such as performance, security, validation, load/stress, and configuration sensitivity. But in our case well focus only on function validation and performance. And in both cases we will use the black-box method of testing.

12.Cost Estimation of the Project along with Cost Estimation Model :-
Analogous estimate of effort or cost
Used for Early Estimate or Individual Activity Estimate
Sample example shown below is for two major deliverables of a software project. You use a previous project as a benchmark for analogous estimation.  Using your experience you will estimate a multiplier. 

	Multipliers:
1.	Prototyping: 0.75.
2.	Testing: 0.5
3.	Deployment: 0.5
Finally, if you want to convert to cost, you would use current rates for the resource.
WBS ID	Previous
Similar Project
Activity	Previous
Effort	Current
Project
Estimate	Multiplier	Effort
(Previous Effort * 0.75)	Cost
(Rs. 500/hr.)
1	Prototyping	40 Work-Hours	Prototyping	0.75	30  Work-hours	Rs. 15000/-
2	Testing	20 Work-Hours	Testing	0.50	10 Work-Hours	Rs. 5000/-
Total					40 Work- Hours	Rs. 20000/-

Note: Effort is also called Size and unit of estimation is called either Work-Hour, person-hours.

# 13.  Future scope and further enhancement of the Project :-
In the future, shoppers will likely increasingly rely on a mix of brick-and-mortar and digital channels for discovery, researching and purchasing. Whether in-store or online, brands can meet shoppers' needs by using data and machine learning to understand behaviors and deliver personalized, seamless experiences.


# 14.    Bibliography :-
•	Object Oriented Programming With C++, E Balagurusamy, TMH
•	Object Oriented Programming in Turbo C++, Robert Lafore, Galgotia
•	The Compete Reference C++, Herbert Schlitz, TMH
•	C++ programming in easy steps


